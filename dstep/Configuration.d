/**
 * Copyright: Copyright (c) 2016 Jacob Carlborg. All rights reserved.
 * Authors: Jacob Carlborg
 * License: $(LINK2 http://www.boost.org/LICENSE_1_0.txt, Boost Software License 1.0)
 */
module dstep.Configuration;

import dstep.translator.Options;

/**
 *  Aggregation of global configuration options affecting the program
 */
struct Configuration
{
    /// app version string, generated by the build system
    enum Version = import("VERSION");

    /// array of file names to translate to D
    string[] inputFiles;

    @("language|x", "Treat subsequent input files as having type <language>.")
    Language language;

    @("version", "Show dstep version.")
    bool dstepVersion;

    @("clang-version", "Show libclang version.")
    bool clangVersion;

    /// array of parameters needed to be forwarded to clang driver
    string[] clangParams;

    /// output file name or folder (in case there are many input files)
    string output;

    @("package", "Use <package> as package name.")
    string packageName;

    @("comments", "Translate comments [default: true].")
    bool enableComments = true;

    @("public-submodules", "Use public imports for submodules [default: false].")
    bool publicSubmodules = false;

    @("reduce-aliases", "Reduce primitive type aliases [default: true].")
    bool reduceAliases = true;

    @("portable-wchar_t", "Translate wchar_t as core.stdc.stddef.wchar_t [default: true].")
    bool portableWCharT = true;

    @("zero-param-is-vararg", "Translate functions with no arguments as variadic functions [default: false].")
    bool zeroParamIsVararg = false;

    @("single-line-function-headers", "Break function headers to multiple lines [default: false].")
    bool singleLineFunctionHeaders = false;

    @("space-after-function-name", "Put a space after a function name [default: true].")
    bool spaceAfterFunctionName = true;
}

template makeGetOptArgs(alias config)
{
    import std.meta;

    template expand(alias spelling)
    {
        static if (
            __traits(compiles, &__traits(getMember, config, spelling)) &&
            __traits(getAttributes, __traits(getMember, config, spelling)).length == 2)
        {
            auto ptr() @property
            {
                return &__traits(getMember, config, spelling);
            }

            alias expand = AliasSeq!(
                __traits(getAttributes, __traits(getMember, config, spelling)),
                ptr);
        }
        else
        {
            alias expand = AliasSeq!();
        }
    }

    alias makeGetOptArgs = staticMap!(expand, __traits(allMembers, typeof(config)));
}

